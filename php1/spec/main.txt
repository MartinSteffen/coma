============================================================================
  TECHNISCHE SPEZIFIKATION DER GRUPPE PHP1
============================================================================

Auf Grundlage von [spec-1.pdf]
von Sandro Esquivel, Tom Scherzer und Jan Waller.

Gruppe PHP1:
 - [sae]  Esquivel, Sandro
 - [dcm]  Miesling, Daniel C.
 - [tos]  Scherzer, Tom
 - [fast] Starke, Falk
 - [jwa]  Waller, Jan

Unsere E-Mailadressen: [...]@informatik.uni-kiel.de



============================================================================
  STAND UND HISTORIE DIESES DOKUMENTS:
============================================================================

Datum    Autor   Änderung(en)
----------------------------------------------------------------------------
07.12.04 tos     Dokument erstellt: Kapitel 1, Appendizes, Konventionen
08.12.04 jwa     Links eingefügt, bissige Kommentare entfernt, Templates 
                 ergänzt, Verzeichnisstruktur ergänzt
09.12.04 jwa     Typos entfernt, Templates ergänzt
09.12.04 sae     Noch mehr Typos entfernt
23.12.04 jwa     Systemvorraussetzungen hinzugefügt
24.12.04 dmi     Anhang Login / Registrieung
24.12.04 jwa     Konventionen "enforced" -> Frage sollte das(^^) Anhang sein? 
07.01.05 dmi     Hinweis auf db_schema.txt und Bedeutung für uns in Kapitel 2.2
08.01.05 tos     Kapitel 2 geändert
09.01.05 dmi     Kapitel 4 Design hinzugefügt
10.01.05 sae     Anmerkung 4.5 (Designstudie) in Kapitel 4 hinzugefuegt,
                 entsprechende Dateien im Appendix Verweise hinzugefuegt. 

Konventionen für dieses Dokument (ups, ganz schön viele...):

- Historie weiterführen, damit der Stand schnell anhand des Datums erkennbar
  ist.
- Neue Rechtschreibung nach bestem Wissen; zumindest keine Schlamperei!
- Maximale Zeilenlänge: 76. (Allgemein gut ausdruckbar.)
- Wörter, die in die vorige Zeile passen und keinen neuen Absatz beginnen,
  sollten nach Möglichkeit dann auch in der vorigen Zeile stehen.
- Keine Worttrennungen am Zeilenende durch Bindestriche (sonst Aufwand bei
  nachträglichen Änderungen), es sei denn, ein überlanges Wort zerstört
  sonst den Lesefluss.
- Lieber häufiger mal einen neuen Absatz anfangen (bessere Wartbarkeit des
  Dokuments bei Änderungen, Einfügungen usw.)
- Vor jedem Kapitel drei Zeilen Abstand, nach der Überschrift (eingerahmt
  von Linien aus Gleichheitszeichen) eine Leerzeile. Beispiel: siehe
  Kapitel 1.
- Vor jedem Unterpunkt zwei Zeilen Abstand. Unterpunkt und dessen
  Überschrift in eine Zeile, gefolgt vom Text direkt in der nächsten Zeile.
  Beispiel: siehe Unterpunkt 1.1.
- Ein unverbindliches Beispiel für eine Tabelle ist in Appendix A.
- Inhaltsverzeichnis aktuell halten.
- Verweise auf andere Quellen stets in eckige Klammern setzen (um schnelles
  Finden bei Änderungen usw. zu ermöglichen) und die Verweise auch ins
  Appendix eintragen.
- Bei Missachtung der Konventionen droht strafrechtliche Verfolgung. ;-)


============================================================================
  INHALT
============================================================================
  1. Überblick über das Konzept
  2. Das Datenmodell (SQL)
  3. Das Datenmodell (PHP)
  4. Design
App. Systemvorraussetzungen
App. Verantwortlichkeiten / Ansprechpartner
App. Verzeichnisstruktur
App. Tests
App. Offene Punkte
App. Verweise
App. Registrierung und Login



============================================================================
  1. ÜBERBLICK ÜBER DAS KONZEPT
============================================================================

Das grobe Konzept unseres Entwurfs ist in [programmschema.jpg] dargestellt.


1.1 Skripte, Formulare, Funktionen
Eine zentrale Rolle nehmen in diesem Konzept die (PHP-)Skripte ein, welche
letztlich den Programmablauf steuern. Formulare sind solche Skriptdateien,
die als GUI dienen, d.h. letztlich dem Benutzer angezeigt werden (siehe
auch [navigator.pdf]) und Interaktionsmöglichkeiten bieten, während
gewöhnliche Skripte neben der Steuerung des Programms auch weniger komplexe
Funktionen (z.B. Berechtigungsprüfungen) durchführen. I.d.R. treten
Formulare mit Skripten (z.B. im Header) gemeinsam auf. Skripte wie
Formulare arbeiten überwiegend auf Objekten, die weiter unten näher
beschrieben werden.
Funktionen sind ebenfalls Skripte, die aber nur aus Programmlogik bestehen
und insbesondere keinerlei Ausgabe auf dem Schirm erzeugen. Stattdessen
werden in den Funktionsmodulen komplexere Berechnungen durchgeführt, die
vom Rest des Programms unabhängig sind (z.B. der Verteilungsalgorithmus für
die Paper).
Im Folgenden fassen wir Formulare und Funktionen unter Skripten zusammen,
es sei denn, eine explizite Unterscheidung ist nötig.


1.2 DB Access
Sämtliche Datenbankzugriffe sind strikt in eine einzige Klasse ausgelagert
(DBAccess). Zu Beginn des Programms wird genau eine DBAccess-Instanz
erzeugt, die auf genau einer Instanz der Klasse MySQL operiert. Auf
Anfragen von Skripten über bereitgestellte Methoden werden bei Erfolg
Ergebnisobjekte (oder primitive Typen, je nach Methode) zurückgeliefert.
Die Methodenparameter hingegen sind ausschließlich primitive Typen. Die
Idee der Datenbankzugriffsschicht ist eine saubere Trennung von
Programmlogik und Datenbank(-anbindung).
Die angebotenen Methoden richten sich stark nach den Anforderungen durch
einzelne Skripte, so dass diese teilweise redundanten SQL-Code enthalten,
dafür aber innerhalb der Skripte i.d.R. ein Aufruf einer DBAccess-Methode
ausreicht, um alle benötigten Informationen zu erhalten.


1.3 Objekte
Unsere Objekte sind - losgelöst von der Datenbankstruktur - in solche
Einheiten gegliedert, die uns für die Skripte besonders günstig erscheinen
(siehe auch [conference.jpg], [forum.jpg], [paper.jpg], [review.jpg]).
Insbesondere fassen Objekte i.d.R. Informationen aus verschiedenen
Datenbanktabellen "sinnvoll" zusammen.
Die Motivation für diese Einteilung ist zum einen, dass die Skripte schnell
und komfortabel auf relevante Informationen zugreifen können, zum anderen
spielen Strukturierungsaspekte (Modularisierung) sowie Effizienz eine Rolle.
Die Objekte besitzen teilweise (je nach Eigenschaften) mehrere Ableitungen,
so dass sie meist nur die den einzelnen Skripten tatsächlich benötigten
Informationen enthalten (und selten mehr).
Ganz wichtig außerdem: Objekte enthalten niemals Datenbankanfragen, weder
direkt, noch über Methodenaufrufe über DBAccess.

Folgendes Beispiel soll das geplante Vorgehen illustrieren:
Das Formular, das dem Chair alle Paper eines Autors auflistet, ruft die
DBAccess-Methode getPapersOfAuthor($intAuthorId) auf und erhält ein Array
von Instanzen des Objekts PaperSimple. In PaperSimple steht u.a. der Titel
eines Papers. Das Formular zeigt diese zeilenweise an. Wird nun ein Paper
mit ID $intPaperId angeklickt, wird ein neues Formular (Detailansicht)
geöffnet, das die DBAccess-Methode getPaperDetailed($intPaperId) aufruft.
Zurückgeliefert wird eine Instanz des Objekts PaperDetailed (übrigens
abgeleitet von PaperSimple), welches z.B. auch die Namen der Co-Autoren
enthält, so dass diese angezeigt werden können.

Anmerkung: Die Klassendefinitionen befinden sich im Unterverzeichnis
include.


1.4 Layout-Templates
Wir benutzen für unsere Formulare Templates, die HTML enthalten mit einigen
zusätzlichen Tags. Syntax für solche selbstdefinierten Tags: {Tag}.

Künstliches Beispiel: <p>Hello {Firstname} <b>{Lastname}</b>.</p>

Anmerkung: Die Templates befinden sich im Unterverzeichnis templates.

Dort ist die Verzeichnis-Struktur derart gedacht, das es Unterverzeichnisse
gibt die für verschiedene Designs stehen, zZ also zB templates/simplecoma/.
In der zentralen header Datei header.inc.php wird in der Konstanten 
DESIGN festgelegt welches Design verwendet werden soll (dieses
ermöglicht eventuell später für den Benutzer ein Umschalten zwischen 
mehreren Design-Schemata).
Alle Dateien die zu einem Design gehören sollten dementsprechend in einem
entsprechenden Unterverzeichnis (zB /templates/simplecoma/images/) liegen.
Wie man automatisch die korrekten Links setzt zeigen die schon vorhandenen
Beispieldateien.

Beispiele:
<img src="{path}images/logo.jpg">
<a href="{basepath}logout.php{SID}">Logout</a>

Dabei verweist {path} auf das Template-Verzeichnis für Bilder, Stylesheets
etc, während {basepath} auf das Verzeichnis verweist, in dem die zu 
startenden Skripte liegen. {SID} sollte man an zu startende Skripte immer
anhängen, damit bei ausgeschalteten Cookies die SID korrekt übergeben wird.


1.5 Parser
Die Klasse Template enthält einen Parser für Template-Dateien. Für die
Ausgabe von Formularen wird jeweils eine PHP-Datei (mit allen relevanten
Parametern) aufgerufen, welche zunächst die notwendigen Datenbankanfragen
(über DBAccess) durchführt, ein Objekt (oder eine Liste von Objekten)
zurückgeliefert bekommt und dann eine Template-Instanz erzeugt. Diese
benötigt neben dem Layout-Template-Dateinamen auch ein Array, das für jedes
in dem Layout-Template vorkommende Tag die korrespondierende Auflösung
enthält.
Anschließend wird der Inhalt (reines HTML) durch einen Methodenaufruf des
Template-Objekts ausgegeben.
Das Ziel dieses Vorgehens ist, Design (HTML/CSS) und Programmlogik (PHP)
voneinander zu trennen.



============================================================================
  2. DAS DATENMODELL (SQL)
============================================================================

Neben dem für alle Gruppen verbindlichen minimalen Datenmodell, auf Basis
dessen die Datenbank angelegt wird, stellen wir ein Skript bereit, das die
Datenbank fuer unsere Bedürfnisse erweitert und anpasst (siehe Appendix
Verzeichnisstruktur).
Darin werden folgende Tabellen erstellt:

- ConferenceConfig: erweiterte Konferenzkonfiguration
- Session: zur Session-Verwaltung
- Role: Wir halten uns an die Konventionen in [db-Schema.txt] (enumeration
  roles). Die Tabelle Role enthält role_types mit folgenden Bedeutungen:
  +------------------------------------------------------------------------+
  | Role_type   | [db-Schema.txt]  | Entsprechung für PHP1                 |
  +------------------------+-----------------------------------------------+
  |   00        |  without role    |  Teilnehmer                           |
  |   01        |  admin           |   keine                               |
  |   02        |  chair           |    Chair                              |
  |   03        |  reviewer        |  Reviewer                             |
  |   04        |  author          |  Author                               |
  |   05        | participant      |   keine                               |
  +------------------------------------------------------------------------+


============================================================================
  3. DAS DATENMODELL (PHP)
============================================================================

Die wesentlichen Aspekte unserer Modellierung sollten aus Kapitel 1 deutlich
werden. Insbesondere der Abschnitt 1.3 geht in allgemeiner Form auf unsere
Objekte ein.
Die Attribute und Methoden sind in PHP immer public, jedoch ist durch die
@access-Anmerkung (public/protected/private) im [PHPDoc]-Kommentar das
vorgesehene Zugriffsrecht erkennbar.
Sonstige Details sind den entsprechenden Verweisen (s.u.) sowie [PHPDoc] zu
entnehmen.


============================================================================
  4. Design
============================================================================

4.1 e3c-Konformität
Alle unsere Seiten sollten nach einem w3c-Standart validieren. 

4.2 Design [simplecoma] 
Encoding: utf-8
Doctype: 4.0 Transitional

4.3 Navigation
Einen Überblick über die Navigation durch die Seiten ist im Ordner 
[navigation] zu finden. Dort sind zum einen UML-Diagramme zu finden, die 
eine Baumstuktur darstellen. Die obersten Klassen in den UML-Diagrammen
stellen die jeweilige Wurzel des Baumes und somit den Ausgangspunkt der 
Navigation auf dieser Seite dar.
Eine technische Spezifikation der Seitenstruktur und ihrer Navigation
ist in [navigation.txt] zu finden. Dieses Dokument stützt sich
auf die UML-Diagramme, sowie die Spezifikation [spec-1.pdf] und beschreibt
den Inhalt der einzelnen Seiten (statischer Inhalt, Formularfelder, Schalt-
flächen, Menü) und deren Verknüpfung untereinander.


4.4 Benennung von Dateien (php-Seiten)
Die Benennung der Knotenpunkte der Navigation ist aus den UML-Diagrammen im
Ordner [navigation] ersichtlich. Bei der Benennung von Menue und Submenue-
punkten sollte, soweit sinnvoll, darauf geachtet werden, dass der Dateiname
der entspechrenden php-Seite mit der Wurzel beginnt - z.B. start_neue.php.
Die Benennung der Dateien ist noch in [navigation.txt] zu ergänzen.

4.5 Templates
siehe Kapitel 1.4.

4.6 Prototyp (Designstudie)
Das Flash-Movie coma-prototyp.swf soll als Diskussionsgrundlage
und Anschauungsmaterial zur Klärung von Designfragen und Fragen
die Benutzerführung betreffend dienen.
Es dient nur der gruppeninternen Diskussion und ist insbesondere
von Testfällen der Testgruppe auszuschließen.

============================================================================
  APPENDIX: SYSTEMVORRAUSSETZUNGEN
============================================================================

+--------------------------------------------------------------------------+
| Programm    | Version  | Warum diese??                                   |
+------------------------+-------------------------------------------------|
| Apache(??)  | ?        | (muss es überhaupt unbedingt Apache sein?)      |
|             |          |                                                 |
| PHP         | 4.3.0+   | sha1 erst ab da verfügbar (Alternative: (*) )   |
|             |          |                                                 |
| MySQL       | ?        |                                                 |
|             |          |                                                 |
| WebBrowser  | ?        |                                                 |
|             |          |                                                 |
+--------------------------------------------------------------------------+

(*) Code für class.session.inc.php (ähnlich wie in Parser)
//  BACKWARDS COMPATIBILITY WITH PHP VERSIONS < 4.3.0
//  BC for sha1()
if (!function_exists('sha1')) {
  // Implementierung von sha1 (siehe z.B. www.php.net -> sha1)
}



============================================================================
  APPENDIX: VERANTWORTLICHKEITEN / ANSPRECHPARTNER
============================================================================

Wir haben für jedes Thema (Ausnahme: Objekte) einen offiziellen
Verantwortlichen. Da aber i.d.R. mehrere Personen an einem Modul arbeiten,
sind diese hier mit aufgeführt.
Im Code sollen außerdem möglichst durchgängig [PHPDoc]-Kommentare zu finden
sein, die auch die Namen der Autoren jeder einzelnen Methode enthalten.

+--------------------------------------------------------------------------+
|             | Verantw. | Weitere Ansprechpartner                         |
+------------------------+-------------------------------------------------|
| Algorithmen | tos      | fast                                            |
| DBAccess    | sae      | tos                                             |
| Design      | dcm      | sae, jwa (wegen Parser-Anbindung)               |
| Forum       | fast     | jwa                                             |
| Objekte     | alle     |                                                 |
| Parser      | jwa      |                                                 |
| Sessions    | jwa      |                                                 |
+--------------------------------------------------------------------------+

Siehe auch: [liste_interessen.jpg]



============================================================================
  APPENDIX: VERZEICHNISSTRUKTUR
============================================================================

Root-Verzeichnis sei im Folgenden: (...)/php1/coma1.

$/. enthält auch Testdateien. (gekennzeichnet durch test_...)
  Hier liegt die indext.php, (die hauptsächlich eine weiterleitung auf andere
  hier liegende Skriptdateien vornimmt), sowie alle aufrufbaren Skripte
  (zB chair.php für die Chair Verwaltung)
$/include enthält die Klassen.
$/templates enthält die Templates.
$/sql enthält die Datei php1.sql, welches die Datenbank PHP1-spezifisch
  erweitert und anpasst.

Verzeichnisse, die den Namen einzelner Mitglieder enthalten, sowie deren
Unterverzeichnisse dienen als "private" Testumgebung.



============================================================================
  APPENDIX: TESTS
============================================================================

Dieser Anhang enthält Informationen über Module, Klassen, Methoden,
Funktionen usw., die eines ausführlichen Tests bedürfen, sowie die
Ergebnisse der Tests.

----------------------------------------------------------------------------
Tests für Klasse DBAccess: Die einzelnen Methoden müssen getestet werden.
Durchgeführte Tests, Testfälle: -
Gefundene Fehler: -
Auf Korrektheit geprüft (Tester, Datum):
 - getAverageRatingOfPaper* (sae/tos, 06.12.04)
 - getPerson (sae/tos, 03.12.04)
 - getPersonDetailed (sae/tos, 03.12.04)
 - getPersonIdByEmail (sae/tos, 03.12.04)
 - getReviewRating* (sae/tos, 06.12.04)
*) Formel für Ermittlung der Gesamtbewertung noch anpassen!
----------------------------------------------------------------------------
Tests für den Verteilungsalgorithmus: Sobald er spezifiziert und
implementiert ist, sind hierfür vielfältige (!) Testfälle nötig.
Insbesondere ist das Verhalten bei Sonderfällen zu überwachen.
----------------------------------------------------------------------------



============================================================================
  APPENDIX: OFFENE PUNKTE
============================================================================

Dieser Anhang enthält offene Punkte, die geklärt bzw. durchgeführt werden
müssen, und wird demnach häufiger mal aktualisiert. In dieser Phase wird
jedoch darauf verzichtet, sämtliche fehlende Teile zu dokumentieren.
Offene Punkte, die (technische) Spezifikation betreffend, werden ebenfalls
hier aufgeführt.

Betrifft  Offener Punkt
----------------------------------------------------------------------------
Spez      Algorithmen spezifizieren (insbesondere Verteilungsalgorithmus und
          Ermittlung "strittiger" Paper)
Spez      Dateien, auf die verwiesen wird (vgl. Appendix), auf Aktualität
          prüfen und beizeiten in das spec-Verzeichnis schieben
CoMa/Spez einheitliche Fehlerbehandlungsroutinen einführen und dokumentieren
CoMa      [PHPDoc]-Kommentare einfügen und möglichst konsistent halten
CoMa/Spez Ermittlung der Gesamtbewertung (Berechnung gewichteter
          Einzelnoten) korrigieren und dokumentieren


============================================================================
  APPENDIX: VERWEISE
============================================================================

Die Dateien befinden sich zurzeit im Verzeichnis (...)/php1/architecture/.

[coma-prototyp.fla]
[coma-prototyp.swf]
[coma-prototyp.txt]
[liste_interessen.jpg]
[navigator.pdf]
[programmschema.jpg]
[spec-1.pdf] (Original, unverändert und z.T. überholt)
[conference.jpg] (Unterverzeichnis objects)
[forum.jpg] (Unterverzeichnis objects)
[paper.jpg] (Unterverzeichnis objects)
[review.jpg] (Unterverzeichnis objects)

Ferner:
[PHPDoc]         ~wprguest1/coma1doc/
[db-Schema.txt]: ~/svn/coma/trunk/sql/db_schema.txt
[main.tpl]:      ~/svn/coma/trunk/php1/coma1/templates/simplecoma/
[simplecoma]:    ~/svn/coma/trunk/php1/coma1/templates/simplecoma/
[navigation]:    ~/svn/coma/trunk/php1/spec/navigation/


Wir sind bemüht, diese Dateien möglichst aktuell zu halten, jedoch kann
dies während des Entwicklungsprozesses nicht immer garantiert werden. Wir
bitten um Verständnis.



============================================================================
  APPENDIX: Registrierung und Login
============================================================================

Accounts sollen wiederverwendbar sein, d.h. ein Account fuer viele Konferenzen.

Wenn der Benutzer auf die Startseite geht wird er zunaechst 
aufgefordert sich einzuloggen. Danach hat er zunaechst keine Rolle.

Danach hat er im Prinzip folgende Moeglichkeiten:

1. Liste(n) von Konferenzen mit Sortiermoeglichkeiten und Optionen sich in 
   eine Konferenz einzuloggen oder sich zu registrieren.

   Beim Einloggen in eine Konferenz erhaelt der Benutzer die entsprechende 
   Rolle z.B. Autor.

   Beim Registrieren muss der Benutzer angeben welche Rolle er haben will.

   Je nachdem kann er sich anschliessend sofort einloggen oder muss warten, 
   bis jmd seiner gewuenschten Rolle zugestimmt hat.

2. Erstellen einer neuen Konferenz
  
   Der Benutzer muss sich zunaechst einloggen.
   
   Hier muss der Benutzer alle initialen Daten eingeben und kann diese
   auch spaeter nicht mehr aendern (zumindest in der Grundversion nicht -
   spaeter ggf. optional). Der Benutzer wird automatisch zum Chair. 


